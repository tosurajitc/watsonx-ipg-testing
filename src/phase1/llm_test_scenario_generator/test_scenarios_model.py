"""
Test Scenarios Model for the LLM Test Scenario Generator.

This module defines the database model for storing generated test scenarios
in the PostgreSQL database. It includes all relevant fields to match the
scenario structure generated by the LLM.
"""

from django.db import models
from django.utils import timezone


class TestScenario(models.Model):
    """Database model for storing test scenarios."""

    # Priority choices
    PRIORITY_HIGH = 'High'
    PRIORITY_MEDIUM = 'Medium'
    PRIORITY_LOW = 'Low'
    
    PRIORITY_CHOICES = [
        (PRIORITY_HIGH, 'High'),
        (PRIORITY_MEDIUM, 'Medium'),
        (PRIORITY_LOW, 'Low'),
    ]

    # Status choices
    STATUS_NEW = 'New'
    STATUS_APPROVED = 'Approved'
    STATUS_REJECTED = 'Rejected'
    STATUS_UNDER_REVIEW = 'Under Review'
    STATUS_IMPLEMENTED = 'Implemented'
    
    STATUS_CHOICES = [
        (STATUS_NEW, 'New'),
        (STATUS_APPROVED, 'Approved'),
        (STATUS_REJECTED, 'Rejected'),
        (STATUS_UNDER_REVIEW, 'Under Review'),
        (STATUS_IMPLEMENTED, 'Implemented'),
    ]

    # Core fields
    scenario_id = models.CharField(max_length=50, unique=True, help_text="Unique identifier for the test scenario (e.g., TS-001-01)")
    title = models.CharField(max_length=255, help_text="Concise descriptive title of the test scenario")
    description = models.TextField(help_text="Detailed description explaining what needs to be tested")
    priority = models.CharField(max_length=10, choices=PRIORITY_CHOICES, default=PRIORITY_MEDIUM, help_text="Priority level of the test scenario")
    related_requirements = models.TextField(blank=True, null=True, help_text="List of related requirement IDs")
    
    # Metadata fields
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default=STATUS_NEW, help_text="Current status of the test scenario")
    source = models.CharField(max_length=50, help_text="Source of the test scenario (e.g., 'file', 'manual', 'jira')")
    source_details = models.JSONField(blank=True, null=True, help_text="Additional details about the source (file name, JIRA issue, etc.)")
    llm_model = models.CharField(max_length=100, blank=True, null=True, help_text="LLM model used to generate the scenario")
    
    # Ownership and timestamps
    created_by = models.CharField(max_length=100, blank=True, null=True, help_text="User who created or imported the scenario")
    assigned_to = models.CharField(max_length=100, blank=True, null=True, help_text="User assigned to implement the test scenario")
    created_at = models.DateTimeField(default=timezone.now, help_text="Timestamp when the scenario was created")
    updated_at = models.DateTimeField(auto_now=True, help_text="Timestamp when the scenario was last updated")
    
    # Repository integration
    repository_id = models.CharField(max_length=100, blank=True, null=True, help_text="ID in the test repository system (if integrated)")
    sharepoint_url = models.URLField(blank=True, null=True, help_text="URL to the test scenario in SharePoint (if integrated)")
    jira_key = models.CharField(max_length=50, blank=True, null=True, help_text="Associated JIRA key (if integrated)")
    
    # Implementation details
    test_implementation_type = models.CharField(max_length=50, blank=True, null=True, help_text="Type of test implementation (e.g., 'Manual', 'Automated', 'UFT')")
    automation_status = models.CharField(max_length=50, blank=True, null=True, help_text="Status of automation (e.g., 'Not Started', 'In Progress', 'Completed')")
    
    class Meta:
        app_label = 'ui_components'  # Add this line
        db_table = 'test_scenarios'
        ordering = ['-created_at']
        verbose_name = 'Test Scenario'
        verbose_name_plural = 'Test Scenarios'
        indexes = [
            models.Index(fields=['scenario_id']),
            models.Index(fields=['status']),
            models.Index(fields=['priority']),
            models.Index(fields=['created_at']),
        ]

    def __str__(self):
        return f"{self.scenario_id}: {self.title}"

    def get_status_display_class(self):
        """Return a CSS class based on the status for UI display."""
        status_classes = {
            self.STATUS_NEW: 'bg-info',
            self.STATUS_APPROVED: 'bg-success',
            self.STATUS_REJECTED: 'bg-danger',
            self.STATUS_UNDER_REVIEW: 'bg-warning',
            self.STATUS_IMPLEMENTED: 'bg-primary',
        }
        return status_classes.get(self.status, 'bg-secondary')

    def get_priority_display_class(self):
        """Return a CSS class based on the priority for UI display."""
        priority_classes = {
            self.PRIORITY_HIGH: 'priority-high',
            self.PRIORITY_MEDIUM: 'priority-medium',
            self.PRIORITY_LOW: 'priority-low',
        }
        return priority_classes.get(self.priority, 'bg-secondary')